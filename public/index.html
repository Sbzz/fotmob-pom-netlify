<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FotMob POM (Top-5 domestic leagues, 2025–26)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; max-width: 960px; margin: 2rem auto; padding: 0 1rem; line-height: 1.4; }
    textarea, input, button { width: 100%; padding: .6rem; margin: .35rem 0; }
    button { cursor: pointer; }
    pre { background: #f6f8fa; padding: 1rem; overflow: auto; border-radius: 8px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: .75rem; }
    @media (max-width: 720px){ .row3 { grid-template-columns: 1fr; } }
    .actions { display: flex; gap: .75rem; flex-wrap: wrap; }
    .muted { opacity: .8; font-size: .9rem; }
    .ok { color: #0a7; }
    .err { color: #d33; }
  </style>
</head>
<body>
  <h1>FotMob Player-of-the-Match (Top-5 domestic, 2025–26)</h1>
  <p class="muted">This page calls two Netlify Functions: <code>/discover</code> (finds match IDs by date) and <code>/check</code> (verifies POTM). We’ll query <strong>small date chunks</strong> to avoid timeouts.</p>

  <label>Player URLs (one per line)</label>
  <textarea id="urls" rows="8" placeholder="https://www.fotmob.com/players/1467236/lamine-yamal
https://www.fotmob.com/players/1021382/joao-pedro"></textarea>

  <div class="row3">
    <div>
      <label>From (YYYYMMDD)</label>
      <input id="from" type="text" placeholder="20250801" />
    </div>
    <div>
      <label>To (YYYYMMDD)</label>
      <input id="to" type="text" placeholder="(defaults to today)" />
    </div>
    <div>
      <label>Chunk size (days)</label>
      <input id="chunkDays" type="number" value="7" min="1" />
    </div>
  </div>

  <div class="row3">
    <div>
      <label>Max matches per player (cap, optional)</label>
      <input id="maxMatches" type="number" value="0" min="0" />
    </div>
    <div>
      <label>Check concurrency</label>
      <input id="concurrency" type="number" value="3" min="1" />
    </div>
    <div>
      <label>Season filter</label>
      <input type="text" value="Top-5 leagues & 2025–26" disabled />
    </div>
  </div>

  <div class="actions">
    <button id="run">Run</button>
    <button id="downloadCsv" disabled>Download CSV</button>
  </div>

  <h3>Status</h3>
  <pre id="status">—</pre>

  <h3>Output</h3>
  <pre id="out">—</pre>

  <script>
    const out = document.getElementById("out");
    const statusEl = document.getElementById("status");
    const btn = document.getElementById("run");
    const dl = document.getElementById("downloadCsv");
    let lastCsv = "";

    const yyyymmdd = (d) => {
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2, "0");
      const day = String(d.getUTCDate()).padStart(2, "0");
      return `${y}${m}${day}`;
    };
    const todayUTC = () => {
      const now = new Date();
      return yyyymmdd(new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate())));
    };
    const parseUrls = () =>
      document.getElementById("urls").value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

    const safeFetchJSON = async (url, bodyObj) => {
      const res = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json", "accept": "application/json" },
        body: JSON.stringify(bodyObj || {})
      });
      const text = await res.text();
      let data = null; try { data = text ? JSON.parse(text) : null; } catch {}
      return { ok: res.ok, status: res.status, statusText: res.statusText, text, data };
    };

    const chunkRanges = (fromStr, toStr, sizeDays) => {
      const from = new Date(Date.UTC(+fromStr.slice(0,4), +fromStr.slice(4,6)-1, +fromStr.slice(6,8)));
      const to   = new Date(Date.UTC(+toStr.slice(0,4), +toStr.slice(4,6)-1, +toStr.slice(6,8)));
      const chunks = [];
      let cur = new Date(from);
      while (cur <= to) {
        const end = new Date(cur);
        end.setUTCDate(end.getUTCDate() + sizeDays - 1);
        if (end > to) chunks.push({ from: yyyymmdd(cur), to: yyyymmdd(to) });
        else chunks.push({ from: yyyymmdd(cur), to: yyyymmdd(end) });
        cur.setUTCDate(cur.getUTCDate() + sizeDays);
      }
      return chunks;
    };

    const csvFromBundles = (bundles) => {
      const headers = ["player_name","player_url","match_url","match_title","league_label","match_datetime_utc","rating"];
      const lines = [headers.join(",")];
      for (const b of bundles) {
        const pname = (b.player_name || "").replace(/,/g, " ");
        const purl = b.player_url || "";
        for (const r of b.pom_2025_26_domestic || []) {
          lines.push([
            pname, purl, r.match_url || "",
            (r.match_title || "").replace(/,/g, " "),
            (r.league_label || "").replace(/,/g, " "),
            r.match_datetime_utc || "",
            r.rating == null ? "" : String(r.rating)
          ].join(","));
        }
      }
      return lines.join("\n");
    };

    async function runChecksForPlayer(player, concurrency) {
      const { player_url, player_name, match_urls } = player;
      const queue = [...(match_urls || [])];
      const results = [];
      let inFlight = 0, done = 0;

      return new Promise((resolve) => {
        const pump = async () => {
          if (queue.length === 0 && inFlight === 0) return resolve(results);
          while (inFlight < concurrency && queue.length) {
            const matchUrl = queue.shift();
            inFlight++;
            safeFetchJSON("/.netlify/functions/check", { playerName: player_name, matchUrl })
              .then(({ ok, status, statusText, text, data }) => {
                if (!ok || !data) results.push({ match_url: matchUrl, error: ok ? "Empty response" : `HTTP ${status} ${statusText}`, raw: text || null });
                else results.push(data);
              })
              .catch(e => results.push({ match_url: matchUrl, error: String(e) }))
              .finally(() => {
                inFlight--; done++;
                statusEl.textContent = `Checking ${player_name}: ${done}/${match_urls.length} matches…`;
                pump();
              });
          }
        };
        pump();
      });
    }

    btn.onclick = async () => {
      btn.disabled = true; dl.disabled = true; lastCsv = "";
      out.textContent = "—"; statusEl.classList.remove("err","ok");
      statusEl.textContent = "Starting…";

      const urls = parseUrls();
      if (!urls.length) { statusEl.textContent = "Paste at least one player URL."; btn.disabled = false; return; }

      const fromInput = document.getElementById("from").value.trim() || "20250801";
      const toInput   = document.getElementById("to").value.trim()   || todayUTC();
      const chunkDays = Math.max(1, Number(document.getElementById("chunkDays").value || 7));
      const maxMatchesCap = Math.max(0, Number(document.getElementById("maxMatches").value || 0));
      const concurrency = Math.max(1, Number(document.getElementById("concurrency").value || 3));

      const chunks = chunkRanges(fromInput, toInput, chunkDays);
      statusEl.textContent = `Discovering in ${chunks.length} chunk(s)…`;

      // Aggregate players across chunks
      const playerMap = new Map(); // key: player_url -> { player_url, player_name, match_set:Set }
      let totalUnique = 0;

      for (let i = 0; i < chunks.length; i++) {
        const c = chunks[i];
        statusEl.textContent = `Discovering chunk ${i+1}/${chunks.length} (${c.from}..${c.to})…`;
        const disc = await safeFetchJSON("/.netlify/functions/discover", {
          urls, maxMatches: maxMatchesCap, from: c.from, to: c.to
        });

        if (!disc.ok || !disc.data) {
          statusEl.classList.add("err");
          statusEl.textContent = `Discover error in chunk ${i+1}: HTTP ${disc.status} ${disc.statusText}\n` +
            (disc.data ? JSON.stringify(disc.data, null, 2) : (disc.text || "(empty response)"));
          btn.disabled = false; return;
        }

        const players = disc.data.players || [];
        for (const p of players) {
          const key = p.player_url;
          if (!playerMap.has(key)) playerMap.set(key, { player_url: key, player_name: p.player_name, match_set: new Set() });
          const entry = playerMap.get(key);
          for (const u of (p.match_urls || [])) entry.match_set.add(u);
        }
        totalUnique = Array.from(playerMap.values()).reduce((a, b) => a + b.match_set.size, 0);
      }

      // Convert sets to arrays
      const aggregated = Array.from(playerMap.values()).map(e => ({
        player_url: e.player_url,
        player_name: e.player_name,
        match_urls: Array.from(e.match_set)
      }));

      statusEl.textContent = `Discovered ${totalUnique} unique match URLs across ${chunks.length} chunk(s). Starting checks…`;

      // Run checks
      const bundles = [];
      for (const p of aggregated) {
        const checked = await runChecksForPlayer(p, concurrency);
        const filtered = checked.filter(r => r.league_allowed && r.within_season_2025_26 && r.player_is_pom);
        bundles.push({
          player_url: p.player_url,
          player_name: p.player_name,
          checked_matches: checked.length,
          pom_2025_26_domestic_count: filtered.length,
          pom_2025_26_domestic: filtered,
          raw: checked
        });
      }

      // Summaries + CSV
      const totals = bundles.map(b => ({ player_name: b.player_name, total: b.pom_2025_26_domestic_count }));
      const summary = {
        players_processed: bundles.length,
        total_pom_hits_2025_26_domestic: bundles.reduce((a,b)=>a+(b.pom_2025_26_domestic_count||0),0)
      };
      lastCsv = csvFromBundles(bundles); dl.disabled = !lastCsv;

      out.textContent = JSON.stringify({ results: bundles, totals, summary }, null, 2);
      statusEl.classList.add("ok"); statusEl.textContent = "Done.";
      btn.disabled = false;
    };

    dl.onclick = () => {
      if (!lastCsv) return;
      const blob = new Blob([lastCsv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "pom_results_2025_26.csv";
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    };
  </script>
</body>
</html>
