<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FotMob — POTM & Highest Rating (Top-5, 2025–26)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; max-width: 980px; margin: 2rem auto; padding: 0 1rem; line-height: 1.45; }
    textarea, input, button { width: 100%; padding: .65rem; margin: .35rem 0; }
    button { cursor: pointer; }
    pre { background: #f6f8fa; padding: 1rem; overflow: auto; border-radius: 10px; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: .8rem; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: .8rem; }
    @media (max-width: 760px){ .grid-3, .grid-2 { grid-template-columns: 1fr; } }
    .row { display: flex; gap: .8rem; flex-wrap: wrap; }
    .muted { opacity: .8; font-size: .92rem; }
    .ok { color: #0a7; }
    .err { color: #d33; }
  </style>
</head>
<body>
  <h1>FotMob — Player of the Match & Highest Rating (Top-5 leagues, 2025–26)</h1>
  <p class="muted">
    Paste one or more FotMob player URLs. This page calls two Netlify Functions:
    <code>/discover</code> (find Top-5 league match IDs by date chunks) and
    <code>/check</code> (verify POTM and Highest Rating for the player in each match).
  </p>

  <label>Player URLs (one per line)</label>
  <textarea id="urls" rows="8" placeholder="https://www.fotmob.com/players/1467236/lamine-yamal
https://www.fotmob.com/players/1021382/joao-pedro"></textarea>

  <div class="grid-3">
    <div>
      <label>From (YYYYMMDD)</label>
      <input id="from" type="text" placeholder="20250701" />
    </div>
    <div>
      <label>To (YYYYMMDD)</label>
      <input id="to" type="text" placeholder="(defaults to today)" />
    </div>
    <div>
      <label>Chunk size (days)</label>
      <input id="chunkDays" type="number" value="7" min="1" />
    </div>
  </div>

  <div class="grid-3">
    <div>
      <label>Max matches per player (cap per chunk, optional)</label>
      <input id="maxMatches" type="number" value="0" min="0" />
    </div>
    <div>
      <label>Check concurrency (per player)</label>
      <input id="concurrency" type="number" value="3" min="1" />
    </div>
    <div>
      <label>Season filter</label>
      <input type="text" value="Top-5 domestic & 2025–26" disabled />
    </div>
  </div>

  <div class="row">
    <button id="run">Run</button>
    <button id="downloadCsvPOM" disabled>Download CSV — POTM</button>
    <button id="downloadCsvHigh" disabled>Download CSV — Highest Rating</button>
  </div>

  <h3>Status</h3>
  <pre id="status">—</pre>

  <h3>Output</h3>
  <pre id="out">—</pre>

  <script>
    const out = document.getElementById("out");
    const statusEl = document.getElementById("status");
    const btn = document.getElementById("run");
    const dlP = document.getElementById("downloadCsvPOM");
    const dlH = document.getElementById("downloadCsvHigh");
    let lastCsvP = "", lastCsvH = "";

    // ---------- helpers ----------
    const yyyymmdd = (d) => {
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2, "0");
      const day = String(d.getUTCDate()).padStart(2, "0");
      return `${y}${m}${day}`;
    };
    const todayUTC = () => {
      const now = new Date();
      return yyyymmdd(new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate())));
    };
    const parseUrls = () =>
      document.getElementById("urls").value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

    const safeFetchJSON = async (url, bodyObj) => {
      const res = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json", "accept": "application/json" },
        body: JSON.stringify(bodyObj || {})
      });
      const text = await res.text();
      let data = null; try { data = text ? JSON.parse(text) : null; } catch {}
      return { ok: res.ok, status: res.status, statusText: res.statusText, text, data };
    };

    const chunkRanges = (fromStr, toStr, sizeDays) => {
      const from = new Date(Date.UTC(+fromStr.slice(0,4), +fromStr.slice(4,6)-1, +fromStr.slice(6,8)));
      const to   = new Date(Date.UTC(+toStr.slice(0,4), +toStr.slice(4,6)-1, +toStr.slice(6,8)));
      const chunks = [];
      let cur = new Date(from);
      while (cur <= to) {
        const end = new Date(cur);
        end.setUTCDate(end.getUTCDate() + sizeDays - 1);
        if (end > to) chunks.push({ from: yyyymmdd(cur), to: yyyymmdd(to) });
        else chunks.push({ from: yyyymmdd(cur), to: yyyymmdd(end) });
        cur.setUTCDate(cur.getUTCDate() + sizeDays);
      }
      return chunks;
    };

    const csvFromPOM = (bundles) => {
      const headers = ["player_name","player_url","match_url","match_title","league_label","match_datetime_utc","rating"];
      const lines = [headers.join(",")];
      for (const b of bundles) {
        const pname = (b.player_name || "").replace(/,/g, " ");
        const purl = b.player_url || "";
        for (const r of b.pom_2025_26_domestic || []) {
          lines.push([
            pname, purl, r.match_url || "",
            (r.match_title || "").replace(/,/g, " "),
            (r.league_label || "").replace(/,/g, " "),
            r.match_datetime_utc || "",
            r.player_rating == null ? "" : String(r.player_rating)
          ].join(","));
        }
      }
      return lines.join("\n");
    };

    const csvFromHighest = (bundles) => {
      const headers = ["player_name","player_url","match_url","match_title","league_label","match_datetime_utc","player_rating","max_rating"];
      const lines = [headers.join(",")];
      for (const b of bundles) {
        const pname = (b.player_name || "").replace(/,/g, " ");
        const purl = b.player_url || "";
        for (const r of b.highest_2025_26_domestic || []) {
          lines.push([
            pname, purl, r.match_url || "",
            (r.match_title || "").replace(/,/g, " "),
            (r.league_label || "").replace(/,/g, " "),
            r.match_datetime_utc || "",
            r.player_rating == null ? "" : String(r.player_rating),
            r.max_rating == null ? "" : String(r.max_rating)
          ].join(","));
        }
      }
      return lines.join("\n");
    };

    async function runChecksForPlayer(player, concurrency) {
      const { player_url, player_name, player_id, match_urls } = player;
      const queue = [...(match_urls || [])];
      const results = [];
      let inFlight = 0, done = 0;

      return new Promise((resolve) => {
        const pump = async () => {
          if (queue.length === 0 && inFlight === 0) return resolve(results);
          while (inFlight < concurrency && queue.length) {
            const matchUrl = queue.shift();
            inFlight++;
            safeFetchJSON("/.netlify/functions/check", {
              playerId: player_id,          // ← pass playerId
              playerName: player_name,
              matchUrl
            })
              .then(({ ok, status, statusText, text, data }) => {
                if (!ok || !data) {
                  results.push({ match_url: matchUrl, error: ok ? "Empty response" : `HTTP ${status} ${statusText}`, raw: text || null });
                } else {
                  results.push(data);
                }
              })
              .catch(e => results.push({ match_url: matchUrl, error: String(e) }))
              .finally(() => {
                inFlight--; done++;
                statusEl.textContent = `Checking ${player_name}: ${done}/${match_urls.length} matches…`;
                pump();
              });
          }
        };
        pump();
      });
    }

    // ---------- main ----------
    btn.onclick = async () => {
      btn.disabled = true;
      dlP.disabled = true; dlH.disabled = true; lastCsvP = ""; lastCsvH = "";
      out.textContent = "—"; statusEl.classList.remove("err","ok");
      statusEl.textContent = "Starting…";

      const urls = parseUrls();
      if (!urls.length) { statusEl.textContent = "Paste at least one player URL."; btn.disabled = false; return; }

      const fromInput = document.getElementById("from").value.trim() || "20250701";
      const toInput   = document.getElementById("to").value.trim()   || todayUTC();
      const chunkDays = Math.max(1, Number(document.getElementById("chunkDays").value || 7));
      const maxMatchesCap = Math.max(0, Number(document.getElementById("maxMatches").value || 0));
      const concurrency = Math.max(1, Number(document.getElementById("concurrency").value || 3));

      const chunks = chunkRanges(fromInput, toInput, chunkDays);
      statusEl.textContent = `Discovering in ${chunks.length} chunk(s)…`;

      // Aggregate across chunks: player_url -> { player_url, player_name, player_id, match_set:Set }
      const playerMap = new Map();
      for (let i = 0; i < chunks.length; i++) {
        const c = chunks[i];
        statusEl.textContent = `Discovering chunk ${i+1}/${chunks.length} (${c.from}..${c.to})…`;
        const disc = await safeFetchJSON("/.netlify/functions/discover", {
          urls, maxMatches: maxMatchesCap, from: c.from, to: c.to
        });

        if (!disc.ok || !disc.data) {
          statusEl.classList.add("err");
          statusEl.textContent = `Discover error in chunk ${i+1}: HTTP ${disc.status} ${disc.statusText}\n` +
            (disc.data ? JSON.stringify(disc.data, null, 2) : (disc.text || "(empty response)"));
          btn.disabled = false; return;
        }

        for (const p of (disc.data.players || [])) {
          const key = p.player_url;
          if (!playerMap.has(key)) {
            playerMap.set(key, { player_url: key, player_name: p.player_name, player_id: p.player_id, match_set: new Set() });
          }
          const entry = playerMap.get(key);
          (p.match_urls || []).forEach(u => entry.match_set.add(u));
          // prefer the first non-null player_id/player_name seen
          if (entry.player_id == null && p.player_id != null) entry.player_id = p.player_id;
          if (!entry.player_name && p.player_name) entry.player_name = p.player_name;
        }
      }

      const aggregated = Array.from(playerMap.values()).map(e => ({
        player_url: e.player_url,
        player_name: e.player_name,
        player_id: e.player_id,
        match_urls: Array.from(e.match_set)
      }));

      const totalUnique = aggregated.reduce((a, b) => a + b.match_urls.length, 0);
      statusEl.textContent = `Discovered ${totalUnique} unique match URLs across ${chunks.length} chunk(s). Starting checks…`;

      const bundles = [];
      for (const p of aggregated) {
        const checked = await runChecksForPlayer(p, concurrency);

        // Filter for Top-5 + season window
        const valid = checked.filter(r => r.league_allowed && r.within_season_2025_26);
        const hitsPotm = valid.filter(r => r.player_is_pom);
        const hitsHighest = valid.filter(r => r.has_highest_rating);

        bundles.push({
          player_url: p.player_url,
          player_name: p.player_name,
          checked_matches: checked.length,
          pom_2025_26_domestic_count: hitsPotm.length,
          highest_rating_count: hitsHighest.length,    // NEW
          pom_2025_26_domestic: hitsPotm,
          highest_2025_26_domestic: hitsHighest,       // NEW
          raw: checked
        });
      }

      // Summaries + CSV
      const totals = bundles.map(b => ({
        player_name: b.player_name,
        potm_total: b.pom_2025_26_domestic_count,
        highest_rating_total: b.highest_rating_count
      }));
      const summary = {
        players_processed: bundles.length,
        total_pom_hits_2025_26_domestic: bundles.reduce((a,b)=>a+(b.pom_2025_26_domestic_count||0),0),
        total_highest_rating_hits_2025_26_domestic: bundles.reduce((a,b)=>a+(b.highest_rating_count||0),0)
      };

      lastCsvP = csvFromPOM(bundles);
      lastCsvH = csvFromHighest(bundles);
      dlP.disabled = !lastCsvP;
      dlH.disabled = !lastCsvH;

      // Compact KPI header + full JSON
      const kpis = bundles.map(b =>
        `• ${b.player_name}: checked ${b.checked_matches}, POTM ${b.pom_2025_26_domestic_count}, Highest ${b.highest_rating_count}`
      ).join("\n");

      out.textContent = `Summary:\n${kpis}\n\n` + JSON.stringify({ results: bundles, totals, summary }, null, 2);
      statusEl.classList.add("ok"); statusEl.textContent = "Done.";
      btn.disabled = false;
    };

    dlP.onclick = () => {
      if (!lastCsvP) return;
      const blob = new Blob([lastCsvP], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "pom_results_2025_26.csv";
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    };
    dlH.onclick = () => {
      if (!lastCsvH) return;
      const blob = new Blob([lastCsvH], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "highest_rating_results_2025_26.csv";
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    };
  </script>
</body>
</html>
