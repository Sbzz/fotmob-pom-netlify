<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FotMob — POTM & Highest Rating (Top-5, 2025–26)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1220; --card: #0f172a; --muted: #94a3b8; --text: #e5e7eb;
      --accent: #4f46e5; --accent-2: #10b981; --danger: #ef4444; --warn: #f59e0b;
      --code: #0b1020; --success-bg: #062b1a; --success-border: #0ea861;
      --error-bg: #311016; --error-border: #f87171;
    }
    * { box-sizing: border-box; }
    body { background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 0; padding: 32px 16px 56px; }
    .container { max-width: 1100px; margin: 0 auto; }
    h1 { margin: 0 0 12px; font-size: 28px; font-weight: 700; }
    p.muted { color: var(--muted); margin-top: 0; }
    .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 14px; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 860px){ .grid, .grid-2 { grid-template-columns: 1fr; } }
    .card { background: var(--card); border: 1px solid #1f2937; border-radius: 14px; padding: 16px; box-shadow: 0 8px 16px rgba(0,0,0,0.25); }
    label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 6px; }
    textarea, input, button { width: 100%; padding: 12px; border-radius: 10px; border: 1px solid #233044; background: #0b1220; color: var(--text); outline: none; }
    textarea::placeholder, input::placeholder { color: #6b7280; }
    textarea:focus, input:focus { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(79,70,229,0.25); }
    .row { display: flex; gap: 10px; flex-wrap: wrap; }
    .btn { border: 1px solid #2b374f; background: linear-gradient(180deg, #1b2540, #151e35); color: #fff; cursor: pointer; transition: transform .06s ease, box-shadow .2s ease; font-weight: 600; }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(16,24,40,.35); }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .btn-accent { background: linear-gradient(180deg, #5661ff, #3843d0); border-color: #3641c8; }
    .btn-green { background: linear-gradient(180deg, #16c78a, #0ea66f); border-color: #0ea66f; }
    .badge { display:inline-block; padding: 6px 10px; border-radius: 999px; font-size: 12px; border:1px solid #334155; background:#0b1325; color:#cbd5e1; }
    .badge.warn { border-color: var(--warn); color:#fde68a; }
    .badge.ok { border-color: var(--success-border); color:#a7f3d0; background: var(--success-bg); }
    .badge.err { border-color: var(--danger); color:#fecaca; background: var(--error-bg); }
    pre { background: var(--code); border: 1px solid #1f2937; border-radius: 12px; padding: 14px; overflow: auto; max-height: 520px; font-size: 13px; line-height: 1.35; }
    .summary { background: #10223a; border: 1px solid #244a78; border-radius: 12px; padding: 12px 14px; white-space: pre-wrap; font-weight: 600; }
    .muted-small { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>FotMob — POTM & Highest Rating (Top-5, 2025–26)</h1>
    <p class="muted">We try a per-player discover first. If it returns zero, we fall back to a fast Top-5 calendar scan for the date range and let the checker filter for your player.</p>

    <div class="card" style="margin-bottom:14px">
      <div class="grid">
        <div>
          <label>Player URLs (one per line)</label>
          <textarea id="urls" rows="7" placeholder="https://www.fotmob.com/players/1467236/lamine-yamal
https://www.fotmob.com/players/1021382/joao-pedro"></textarea>
        </div>
        <div>
          <label>From (YYYYMMDD)</label>
          <input id="from" type="text" value="20250701" />
          <label style="margin-top:12px">To (YYYYMMDD)</label>
          <input id="to" type="text" placeholder="(defaults to today)" />
          <label style="margin-top:12px">Chunk size (days)</label>
          <input id="chunkDays" type="number" value="7" min="1" />
          <div class="muted-small">Used only if discover returns zero; we call calendar in chunks.</div>
        </div>
        <div>
          <label>Max matches per player (cap)</label>
          <input id="maxMatches" type="number" min="0" value="60" />
          <div class="muted-small">0 = no cap.</div>
          <label style="margin-top:12px">Check concurrency (per player)</label>
          <input id="concurrency" type="number" min="1" value="3" />
          <label style="margin-top:12px">Actions</label>
          <div class="row">
            <button id="run" class="btn btn-accent">Run</button>
            <button id="downloadCsvPOM" class="btn btn-green" disabled>CSV — POTM</button>
            <button id="downloadCsvHigh" class="btn" disabled>CSV — Highest</button>
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-bottom:14px">
      <div class="row" style="align-items:center; justify-content:space-between">
        <div><span class="badge" id="statusTag">Idle</span></div>
        <div class="muted-small">Debug shows which path succeeded: Discover (XHR/anchors/next) or Calendar fallback.</div>
      </div>
      <div class="summary" id="summaryBox" style="margin-top:10px">—</div>
    </div>

    <div class="grid-2">
      <div class="card">
        <h3 style="margin-top:0">Status</h3>
        <pre id="status">—</pre>
      </div>
      <div class="card">
        <h3 style="margin-top:0">Output (JSON)</h3>
        <pre id="out">—</pre>
      </div>
    </div>
  </div>

  <script>
    const out = document.getElementById("out");
    const statusEl = document.getElementById("status");
    const statusTag = document.getElementById("statusTag");
    const summaryBox = document.getElementById("summaryBox");
    const btn = document.getElementById("run");
    const dlP = document.getElementById("downloadCsvPOM");
    const dlH = document.getElementById("downloadCsvHigh");
    let lastCsvP = "", lastCsvH = "";

    const yyyymmdd = (d) => {
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2, "0");
      const day = String(d.getUTCDate()).padStart(2, "0");
      return `${y}${m}${day}`;
    };
    const todayUTC = () => {
      const now = new Date();
      return yyyymmdd(new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate())));
    };
    const parseUrls = () => document.getElementById("urls").value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

    async function safeFetchJSON(url, bodyObj){
      const res = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json", "accept": "application/json" },
        body: JSON.stringify(bodyObj || {})
      });
      const text = await res.text();
      let data = null; try { data = text ? JSON.parse(text) : null; } catch {}
      return { ok: res.ok, status: res.status, statusText: res.statusText, text, data };
    }

    function setTag(text, klass){
      statusTag.textContent = text;
      statusTag.className = "badge " + (klass || "");
    }

    function summarisePlayers(players){
      if (!players || !players.length) return "No players.";
      return players.map(p => {
        const d = p.debug || {};
        return `• ${p.player_name || "(unknown)"} — matches:${(p.match_urls||[]).length}  [XHR:${d.xhr_hit? "✓":"×"} PF:${d.page_fetch? "✓":"×"} anchors:${d.anchors_found||0} next:${d.next_ids||0}]`;
      }).join("\n");
    }

    function chunkRanges(fromStr, toStr, sizeDays){
      const from = new Date(Date.UTC(+fromStr.slice(0,4), +fromStr.slice(4,6)-1, +fromStr.slice(6,8)));
      const to   = new Date(Date.UTC(+toStr.slice(0,4), +toStr.slice(4,6)-1, +toStr.slice(6,8)));
      const chunks = [];
      let cur = new Date(from);
      while(cur <= to){
        const end = new Date(cur);
        end.setUTCDate(end.getUTCDate() + sizeDays - 1);
        if (end > to) chunks.push({ from: yyyymmdd(cur), to: yyyymmdd(to) });
        else chunks.push({ from: yyyymmdd(cur), to: yyyymmdd(end) });
        cur.setUTCDate(cur.getUTCDate() + sizeDays);
      }
      return chunks;
    }

    function csvFromPOM(bundles){
      const headers = ["player_name","player_url","match_url","match_title","league_label","match_datetime_utc","player_rating"];
      const lines = [headers.join(",")];
      for (const b of bundles) {
        const pname = (b.player_name || "").replace(/,/g, " ");
        const purl = b.player_url || "";
        for (const r of b.pom_2025_26_domestic || []) {
          lines.push([pname, purl, r.match_url || "", (r.match_title || "").replace(/,/g, " "),
            (r.league_label || "").replace(/,/g, " "), r.match_datetime_utc || "", r.player_rating == null ? "" : String(r.player_rating)].join(","));
        }
      }
      return lines.join("\n");
    }
    function csvFromHighest(bundles){
      const headers = ["player_name","player_url","match_url","match_title","league_label","match_datetime_utc","player_rating","max_rating"];
      const lines = [headers.join(",")];
      for (const b of bundles) {
        const pname = (b.player_name || "").replace(/,/g, " ");
        const purl = b.player_url || "";
        for (const r of b.highest_2025_26_domestic || []) {
          lines.push([pname, purl, r.match_url || "", (r.match_title || "").replace(/,/g, " "),
            (r.league_label || "").replace(/,/g, " "), r.match_datetime_utc || "",
            r.player_rating == null ? "" : String(r.player_rating),
            r.max_rating == null ? "" : String(r.max_rating)].join(","));
        }
      }
      return lines.join("\n");
    }

    async function runChecksForPlayer(player, concurrency){
      const { player_url, player_name, player_id, match_urls } = player;
      const queue = [...(match_urls || [])];
      const results = [];
      let inFlight=0, done=0;

      return new Promise((resolve) => {
        const pump = async () => {
          if (queue.length === 0 && inFlight === 0) return resolve(results);
          while (inFlight < concurrency && queue.length){
            const matchUrl = queue.shift();
            inFlight++;
            safeFetchJSON("/.netlify/functions/check", { playerId: player_id, playerName: player_name, matchUrl })
              .then(({ ok, status, statusText, text, data }) => {
                if (!ok || !data) results.push({ match_url: matchUrl, error: ok ? "Empty response" : `HTTP ${status} ${statusText}`, raw: text || null });
                else results.push(data);
              })
              .catch(e => results.push({ match_url: matchUrl, error: String(e) }))
              .finally(() => { inFlight--; done++; statusEl.textContent = `Checking ${player_name}: ${done}/${match_urls.length}…`; pump(); });
          }
        };
        pump();
      });
    }

    document.getElementById("run").onclick = async () => {
      btn.disabled = true; dlP.disabled = true; dlH.disabled = true; lastCsvP = ""; lastCsvH = "";
      out.textContent = "—"; statusEl.textContent = "Starting…"; summaryBox.textContent = "—"; setTag("Working…","warn");

      const urls = parseUrls();
      if (!urls.length){ statusEl.textContent = "Paste at least one player URL."; setTag("Idle"); btn.disabled = false; return; }

      const fromInput = document.getElementById("from").value.trim() || "20250701";
      const toInput   = document.getElementById("to").value.trim()   || todayUTC();
      const chunkDays = Math.max(1, Number(document.getElementById("chunkDays").value || 7));
      const maxMatchesCap = Math.max(0, Number(document.getElementById("maxMatches").value || 60));
      const concurrency = Math.max(1, Number(document.getElementById("concurrency").value || 3));

      // 1) Discover (per player)
      setTag("Discovering…","warn");
      const disc = await safeFetchJSON("/.netlify/functions/discover", { urls, maxMatches: maxMatchesCap });
      if (!disc.ok || !disc.data){
        setTag("Discover error","err");
        statusEl.textContent = `Discover error: HTTP ${disc.status} ${disc.statusText}\n` + (disc.data ? JSON.stringify(disc.data, null, 2) : (disc.text || "(empty response)"));
        btn.disabled = false; return;
      }
      let players = disc.data.players || [];
      summaryBox.textContent = players.length ? players.map(p => {
        const d = p.debug || {};
        return `• ${p.player_name || "(unknown)"} — matches:${(p.match_urls||[]).length}  [XHR:${d.xhr_hit? "✓":"×"} PF:${d.page_fetch? "✓":"×"} anchors:${d.anchors_found||0} next:${d.next_ids||0}]`;
      }).join("\n") : "No players.";

      // 2) Fallback for any player with zero matches → use calendar in chunks
      const needsFallback = players.filter(p => !p.match_urls || p.match_urls.length === 0);
      if (needsFallback.length){
        const chunks = (function chunkRanges(fromStr,toStr,sizeDays){
          const from = new Date(Date.UTC(+fromStr.slice(0,4), +fromStr.slice(4,6)-1, +fromStr.slice(6,8)));
          const to   = new Date(Date.UTC(+toStr.slice(0,4), +toStr.slice(4,6)-1, +toStr.slice(6,8)));
          const arr=[]; let cur=new Date(from);
          while(cur<=to){ const end=new Date(cur); end.setUTCDate(end.getUTCDate()+sizeDays-1);
            if(end>to) arr.push({from: yyyymmdd(cur), to: yyyymmdd(to)}); else arr.push({from: yyyymmdd(cur), to: yyyymmdd(end)});
            cur.setUTCDate(cur.getUTCDate()+sizeDays);
          } return arr;
        })(fromInput, toInput, chunkDays);

        const union = new Set();
        for (let i=0;i<chunks.length;i++){
          const c = chunks[i];
          statusEl.textContent = `Calendar fallback ${i+1}/${chunks.length} (${c.from}..${c.to})…`;
          const cal = await safeFetchJSON("/.netlify/functions/calendar", { from: c.from, to: c.to });
          if (!cal.ok || !cal.data){
            setTag("Calendar error","err");
            statusEl.textContent = `Calendar error chunk ${i+1}: HTTP ${cal.status} ${cal.statusText}\n` + (cal.data ? JSON.stringify(cal.data, null, 2) : (cal.text || "(empty response)"));
            btn.disabled = false; return;
          }
          (cal.data.match_urls || []).forEach(u => union.add(u));
        }
        // Apply union to each player that had zero
        players = players.map(p => (!p.match_urls || p.match_urls.length === 0)
          ? { ...p, match_urls: Array.from(union).slice(0, maxMatchesCap>0 ? maxMatchesCap : undefined), debug: { ...(p.debug||{}), fallback_calendar: true, fallback_total: union.size } }
          : p
        );

        summaryBox.textContent += `\n(Fallback) Added ${union.size} calendar matches for zero-hit players.`;
      }

      // 3) Check (fan out)
      const bundles = [];
      for (const p of players){
        const checked = await runChecksForPlayer(p, concurrency);
        const valid = checked.filter(r => r.league_allowed && r.within_season_2025_26);
        const hitsPotm = valid.filter(r => r.player_is_pom);
        const hitsHighest = valid.filter(r => r.has_highest_rating);

        bundles.push({
          player_url: p.player_url,
          player_name: p.player_name,
          checked_matches: checked.length,
          pom_2025_26_domestic_count: hitsPotm.length,
          highest_rating_count: hitsHighest.length,
          pom_2025_26_domestic: hitsPotm,
          highest_2025_26_domestic: hitsHighest,
          raw: checked,
          debug: p.debug
        });
      }

      // 4) Output + CSV
      const totals = bundles.map(b => ({
        player_name: b.player_name,
        potm_total: b.pom_2025_26_domestic_count,
        highest_rating_total: b.highest_rating_count
      }));
      const summary = {
        players_processed: bundles.length,
        total_pom_hits_2025_26_domestic: bundles.reduce((a,b)=>a+(b.pom_2025_26_domestic_count||0),0),
        total_highest_rating_hits_2025_26_domestic: bundles.reduce((a,b)=>a+(b.highest_rating_count||0),0)
      };

      lastCsvP = (function csvPOM(b){ const headers=["player_name","player_url","match_url","match_title","league_label","match_datetime_utc","player_rating"]; const lines=[headers.join(",")]; for(const B of b){ const nm=(B.player_name||"").replace(/,/g," "); const pu=B.player_url||""; for(const r of B.pom_2025_26_domestic||[]){ lines.push([nm,pu,r.match_url||"", (r.match_title||"").replace(/,/g," "), (r.league_label||"").replace(/,/g," "), r.match_datetime_utc||"", r.player_rating==null?"":String(r.player_rating)].join(",")); } } return lines.join("\n"); })(bundles);
      lastCsvH = (function csvHigh(b){ const headers=["player_name","player_url","match_url","match_title","league_label","match_datetime_utc","player_rating","max_rating"]; const lines=[headers.join(",")]; for(const B of b){ const nm=(B.player_name||"").replace(/,/g," "); const pu=B.player_url||""; for(const r of B.highest_2025_26_domestic||[]){ lines.push([nm,pu,r.match_url||"", (r.match_title||"").replace(/,/g," "), (r.league_label||"").replace(/,/g," "), r.match_datetime_utc||"", r.player_rating==null?"":String(r.player_rating), r.max_rating==null?"":String(r.max_rating)].join(",")); } } return lines.join("\n"); })(bundles);

      dlP.disabled = !lastCsvP; dlH.disabled = !lastCsvH;

      const kpis = bundles.map(b =>
        `• ${b.player_name}: checked ${b.checked_matches}, POTM ${b.pom_2025_26_domestic_count}, Highest ${b.highest_rating_count}` +
        (b.debug?.fallback_calendar ? `  [fallback: ${b.debug.fallback_total} matches]` : "")
      ).join("\n");

      out.textContent = JSON.stringify({ results: bundles, totals, summary }, null, 2);
      summaryBox.textContent = kpis || "No results.";
      setTag("Done","ok");
      statusEl.textContent = "Completed.";
      btn.disabled = false;
    };

    document.getElementById("downloadCsvPOM").onclick = () => {
      if (!lastCsvP) return;
      const blob = new Blob([lastCsvP], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = "potm_results_2025_26.csv";
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    };
    document.getElementById("downloadCsvHigh").onclick = () => {
      if (!lastCsvH) return;
      const blob = new Blob([lastCsvH], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = "highest_rating_results_2025_26.csv";
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    };
  </script>
</body>
</html>
