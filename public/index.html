<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FotMob — POTM & Stats (Top-5, 2025–26)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0b1220;--card:#0f172a;--muted:#94a3b8;--text:#e5e7eb;
      --accent:#4f46e5;--accent-2:#10b981;--danger:#ef4444;--warn:#f59e0b;
      --code:#0b1020;--success-bg:#062b1a;--success-border:#0ea861;
      --error-bg:#311016;--error-border:#f87171;--border:#1f2937;
    }
    *{box-sizing:border-box}
    body{background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;margin:0;padding:32px 16px 56px}
    .container{max-width:1100px;margin:0 auto}
    h1{margin:0 0 12px;font-size:28px;font-weight:700}
    p.muted{color:var(--muted);margin-top:0}
    .grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    @media (max-width:860px){.grid,.grid-2{grid-template-columns:1fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px;box-shadow:0 8px 16px rgba(0,0,0,.25)}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    textarea,input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #233044;background:#0b1220;color:var(--text);outline:none}
    textarea::placeholder,input::placeholder{color:#6b7280}
    textarea:focus,input:focus{border-color:var(--accent);box-shadow:0 0 0 2px rgba(79,70,229,.25)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .btn{border:1px solid #2b374f;background:linear-gradient(180deg,#1b2540,#151e35);color:#fff;cursor:pointer;transition:transform .06s ease,box-shadow .2s ease;font-weight:600}
    .btn:hover{transform:translateY(-1px);box-shadow:0 6px 18px rgba(16,24,40,.35)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn-accent{background:linear-gradient(180deg,#5661ff,#3843d0);border-color:#3641c8}
    .btn-green{background:linear-gradient(180deg,#16c78a,#0ea66f);border-color:#0ea66f}
    .badge{display:inline-block;padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid #334155;background:#0b1325;color:#cbd5e1}
    .badge.warn{border-color:var(--warn);color:#fde68a}
    .badge.ok{border-color:var(--success-border);color:#a7f3d0;background:var(--success-bg)}
    .badge.err{border-color:var(--danger);color:#fecaca;background:var(--error-bg)}
    pre{background:var(--code);border:1px solid var(--border);border-radius:12px;padding:14px;overflow:auto;max-height:520px;font-size:13px;line-height:1.35}
    .summary{background:#10223a;border:1px solid #244a78;border-radius:12px;padding:12px 14px;white-space:pre-wrap;font-weight:600}
    .muted-small{color:var(--muted);font-size:12px}
    table{width:100%;border-collapse:separate;border-spacing:0 8px}
    thead th{font-size:12px;text-transform:uppercase;letter-spacing:.04em;color:#a8b3c7;text-align:left;padding:6px 10px}
    tbody td{background:#0c1528;border:1px solid #1b2740;padding:10px 12px}
    tbody tr td:first-child{border-top-left-radius:10px;border-bottom-left-radius:10px}
    tbody tr td:last-child{border-top-right-radius:10px;border-bottom-right-radius:10px}
    .progress-bar{height:12px;background:#1e293b;border-radius:8px;overflow:hidden;margin-bottom:6px}
    .progress-fill{
      height:100%;
      background:linear-gradient(90deg,#4f46e5,#10b981);
      width:0%;
      transition:width 0.3s ease, background 0.4s ease;
    }
    .progress-fill.done{ background:#16c78a; }
  </style>
</head>
<body>
  <div class="container">
    <h1>FotMob — POTM & Stats (Top-5, 2025–26)</h1>
    <p class="muted">Paste FotMob player URLs or load <code>url.csv</code> for batch processing. Season restricted to 2025–26, Top-5 leagues.</p>

    <div class="card" style="margin-bottom:14px">
      <div class="grid">
        <div>
          <label>Player URLs (one per line)</label>
          <textarea id="urls" rows="7" placeholder="https://www.fotmob.com/players/1467236/lamine-yamal
https://www.fotmob.com/players/1021382/joao-pedro"></textarea>
          <button class="btn" id="btnLoadCSV" style="margin-top:8px">Load url.csv</button>
        </div>
        <div>
          <label>Max matches per player (cap)</label>
          <input id="maxMatches" type="number" min="0" value="80" />
          <div class="muted-small">0 = no cap.</div>
          <label style="margin-top:12px">Check concurrency (per player)</label>
          <input id="concurrency" type="number" min="1" value="3" />
          <label style="margin-top:12px">Actions</label>
          <div class="row">
            <button id="run" class="btn btn-accent">Run</button>
            <button id="downloadCsvDetails" class="btn btn-green" disabled>Download Details (CSV)</button>
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-bottom:14px">
      <div class="row" style="align-items:center; justify-content:space-between">
        <div><span class="badge" id="statusTag">Idle</span></div>
      </div>
      <div class="summary" id="summaryBox" style="margin-top:10px">—</div>
    </div>

    <div class="grid-2" style="margin-bottom:14px">
      <div class="card">
        <h3 style="margin-top:0">Status</h3>
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        <pre id="status">—</pre>
      </div>
      <div class="card">
        <h3 style="margin-top:0">Output (JSON)</h3>
        <pre id="out">—</pre>
      </div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 10px">Match Results</h3>
      <table>
        <thead>
          <tr>
            <th>Match</th><th>League</th><th>POTM?</th><th>Rating</th><th>G</th><th>NPG</th><th>PG</th><th>A</th><th>YC</th><th>RC</th><th>FMP</th>
          </tr>
        </thead>
        <tbody id="resultsBody">
          <tr><td class="muted" colspan="11">—</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <script>
  (function(){
    const qs = s => document.querySelector(s);
    const urlsEl = qs('#urls');
    const btnLoadCSV = qs('#btnLoadCSV');
    const btnRun = qs('#run');
    const statusEl = qs('#status');
    const statusTag = qs('#statusTag');
    const summaryBox = qs('#summaryBox');
    const out = qs('#out');
    const resultsBody = qs('#resultsBody');
    const dlDetails = qs('#downloadCsvDetails');
    const progressFill = qs('#progressFill');

    let lastDetailsCSV = "";

    function setTag(t, k){ statusTag.textContent = t; statusTag.className = 'badge ' + (k||''); }

    btnLoadCSV.addEventListener('click', async ()=>{
      try {
        let res = await fetch('/url.csv');
        if (!res.ok) res = await fetch('/public/url.csv');
        if (!res.ok) throw new Error('url.csv not found');
        const text = await res.text();
        // handle BOM & header
        const lines = text.replace(/^\uFEFF/, '').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
        const urls = [];
        for (const l of lines) {
          // Accept two formats: "name,url" OR just "url"
          const parts = l.split(',').map(p => p.trim());
          if (parts.length === 1) {
            urls.push(parts[0]);
          } else {
            // take last column as URL (safe for "name,url" and if name contains comma)
            urls.push(parts.slice(-1)[0]);
          }
        }
        urlsEl.value = urls.join('\n');
        summaryBox.textContent = `Loaded ${urls.length} URLs from url.csv`;
      } catch (e) {
        summaryBox.textContent = `CSV load error: ${String(e)}`;
      }
    });

    function toDetailsCSV(bundles){
      const rows=[["player_name","player_url","match_url","match_title","league","potm","rating","goals","npg","pg","assists","yc","rc","fmp"]];
      function rname(p){ return p.player_name || ""; }
      for (const p of bundles){
        for (const r of (p.raw||[])){
          if (!r || !r.match_url) continue;
          const s = r.stats || {};
          rows.push([
            rname(p), p.player_url || "", r.match_url || "", r.match_title || r.resolved_match_id || "", r.league_label ?? "",
            r.player_is_pom ? "1" : "0",
            (r.player_rating!=null?String(Number(r.player_rating).toFixed(2)):""),
            s.goals??'', Math.max(0, Number(s.goals||0) - Number(s.penalty_goals||0)),
            s.penalty_goals??'', s.assists??'', s.yellow_cards??'', s.red_cards??'', s.full_match_played ? "1":"0"
          ]);
        }
      }
      return rows.map(r=>r.join(",")).join("\n");
    }

    function renderResults(bundles){
      resultsBody.innerHTML = "";
      for (const p of bundles){
        for (const r of (p.raw||[])){
          if (!r || !r.match_url) continue;
          const s = r.stats || {};
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${r.match_title || r.resolved_match_id || ''}</td>
            <td>${r.league_label ?? ''}</td>
            <td>${r.player_is_pom ? "✓" : ""}</td>
            <td>${r.player_rating ?? ''}</td>
            <td>${s.goals ?? ''}</td>
            <td>${Math.max(0, Number(s.goals || 0) - Number(s.penalty_goals || 0))}</td>
            <td>${s.penalty_goals ?? ''}</td>
            <td>${s.assists ?? ''}</td>
            <td>${s.yellow_cards ?? ''}</td>
            <td>${s.red_cards ?? ''}</td>
            <td>${s.full_match_played ? "✓" : ""}</td>
          `;
          resultsBody.appendChild(tr);
        }
      }
      if (!resultsBody.children.length) resultsBody.innerHTML = '<tr><td class="muted" colspan="11">No results</td></tr>';
    }

    async function runChecksForPlayer(p, concurrency, onProgress, updateGlobal) {
      const queue = [...(p.match_urls || [])];
      const results = [];
      let inFlight = 0, idx = 0, done = 0;

      return new Promise((resolve) => {
        const pump = () => {
          while (inFlight < concurrency && idx < queue.length) {
            const matchUrl = queue[idx++];
            inFlight++;
            fetch("/.netlify/functions/check", {
              method: "POST",
              headers: { "content-type":"application/json" },
              body: JSON.stringify({ matchUrl, playerId: p.player_id, playerName: p.player_name })
            })
            .then(async res => {
              // defensive JSON parsing
              const txt = await res.text();
              try { return { ok:true, json: txt ? JSON.parse(txt) : null }; }
              catch(err) { return { ok:false, text: txt, status: res.status, statusText: res.statusText }; }
            })
            .then(resp => {
              if (!resp.ok) {
                results.push({ match_url: matchUrl, error: `HTTP ${resp.status} ${resp.statusText}`, raw: resp.text });
              } else {
                results.push(resp.json || resp.json === null ? resp.json : resp.json);
              }
            })
            .catch(e => results.push({ match_url: matchUrl, error: String(e) }))
            .finally(() => {
              inFlight--; done++;
              if (onProgress) onProgress(done, queue.length, p);
              if (updateGlobal) updateGlobal();
              pump();
            });
          }
          if (inFlight === 0 && idx >= queue.length) resolve(results);
        };
        pump();
      });
    }

    btnRun.onclick = async ()=>{
      try {
        btnRun.disabled = true;
        setTag("Working…","warn");
        summaryBox.textContent = "Starting…";
        statusEl.textContent = "Running pipeline…";
        progressFill.style.width = "0%";
        progressFill.classList.remove("done");

        const urls = urlsEl.value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        if (!urls.length) { setTag("Idle"); btnRun.disabled=false; return; }

        // Discover
        const discRes = await fetch("/.netlify/functions/discover", {
          method: "POST",
          headers: { "content-type":"application/json" },
          body: JSON.stringify({ urls, maxMatches: Number(qs('#maxMatches').value||0) })
        });

        let discJson = null;
        try {
          discJson = await discRes.json();
        } catch (e) {
          const txt = await discRes.text();
          statusEl.textContent = `Discover parse error (${discRes.status}): ${txt.slice(0,200)}`;
          setTag("Error","err");
          btnRun.disabled = false;
          return;
        }

        if (!discJson || !Array.isArray(discJson.players)) {
          statusEl.textContent = `Discover returned unexpected payload: ${JSON.stringify(discJson).slice(0,1000)}`;
          setTag("Error","err");
          btnRun.disabled = false;
          return;
        }

        const players = discJson.players;
        // quick debug display of discovered counts for each player
        summaryBox.textContent = players.map(p => `${p.player_name || p.player_url} → ${ (p.match_urls||[]).length } matches`).join("\n");

        // total matches for global progress
        const totalMatches = players.reduce((a,p)=> a + ((p.match_urls||[]).length), 0);
        let globalDone = 0;
        const concurrency = Math.max(1, Number(qs('#concurrency').value || 3));
        const bundles = [];
        const progressState = {};

        function updateGlobalProgress() {
          const pct = totalMatches > 0 ? Math.round((globalDone/totalMatches)*1000)/10 : 0;
          progressFill.style.width = pct + "%";
          if (globalDone >= totalMatches && totalMatches > 0) progressFill.classList.add("done");
        }

        function updateStatusLines() {
          const lines = [ `GLOBAL: ${globalDone}/${totalMatches} matches checked` ];
          for (const p of players) {
            const st = progressState[p.player_name] || { done:0, total: (p.match_urls||[]).length };
            lines.push(`${p.player_name || p.player_url} — ${st.done}/${st.total}`);
          }
          statusEl.textContent = lines.join("\n");
        }

        for (const p of players) {
          progressState[p.player_name] = { done: 0, total: (p.match_urls||[]).length };
          const checked = await runChecksForPlayer(p, concurrency,
            (done,total,pp) => {
              progressState[pp.player_name] = { done, total };
              updateStatusLines();
            },
            () => { globalDone++; updateGlobalProgress(); updateStatusLines(); }
          );
          // for any non-json returned entries we attempted to put the raw text; normalize shape
          const normalized = (checked || []).map(item => {
            if (!item) return { match_url: null, error: "empty response" };
            if (item.ok === false && item.raw) return { match_url: null, error: "non-json", raw_text: item.raw };
            // item may be the parsed object already
            return item;
          });
          bundles.push({ ...p, raw: normalized });
        }

        // render results and CSV
        renderResults(bundles);
        lastDetailsCSV = toDetailsCSV(bundles);
        dlDetails.disabled = !lastDetailsCSV;
        out.textContent = JSON.stringify({ results: bundles }, null, 2);
        setTag("Done","ok");
        summaryBox.textContent = "Completed.";
      } catch (e) {
        setTag("Error","err");
        statusEl.textContent = String(e);
      } finally {
        btnRun.disabled = false;
      }
    };

    dlDetails.onclick = ()=> {
      if (!lastDetailsCSV) return;
      const blob = new Blob([lastDetailsCSV], { type: "text/csv" });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "details.csv";
      a.click();
    };

  })();
  </script>
</body>
</html>
